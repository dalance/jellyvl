

// 符号なし整数マルチサイクル除算器
module divider_unsigned_multicycle #(
    parameter DIVIDEND_WIDTH : u32 = 32            ,
    parameter DIVISOR_WIDTH  : u32 = 32            ,
    parameter QUOTIENT_WIDTH : u32 = DIVIDEND_WIDTH,
    parameter REMAINDER_WIDTH: u32 = DIVISOR_WIDTH ,
) (
    reset: input logic,
    clk  : input logic,
    cke  : input logic,

    // input
    s_dividend: input  logic<DIVIDEND_WIDTH>, // 被除数
    s_divisor : input  logic<DIVISOR_WIDTH> , // 除数
    s_valid   : input  logic                ,
    s_ready   : output logic                ,

    // output
    m_quotient : output logic<QUOTIENT_WIDTH> ,
    m_remainder: output logic<REMAINDER_WIDTH>,
    m_valid    : output logic                 ,
    m_ready    : input  logic                 ,
) {

    // param
    localparam CYCLE      : u32 = QUOTIENT_WIDTH;
    localparam CYCLE_WIDTH: u32 = if $clog2(CYCLE+1) >: 0 {
        $clog2(CYCLE+1)
    } else {
        1
    };

    // type
    localparam t_cycle      : type = logic<CYCLE_WIDTH>;
    localparam t_dividend   : type = logic<DIVIDEND_WIDTH>;
    localparam t_divisor    : type = logic<DIVISOR_WIDTH>;
    localparam t_quotient   : type = logic<QUOTIENT_WIDTH>;
    localparam t_remainder  : type = logic<REMAINDER_WIDTH>;
    localparam t_shiftreg   : type = logic<DIVISOR_WIDTH + QUOTIENT_WIDTH>;
    localparam t_subtraction: type = logic<1 + DIVISOR_WIDTH>;

    var busy       : logic        ;
    var cycle      : t_cycle      ;
    var divisor    : t_divisor    ;
    var shiftreg   : t_shiftreg   ;
    var shiftreg_in : t_shiftreg;
    var shiftreg_next : t_shiftreg;
    var subtraction: t_subtraction;

    var sub_sign : logic    ;
    var sub_value: t_divisor;
    assign sub_sign  = subtraction[DIVISOR_WIDTH];
    assign sub_value = subtraction[DIVISOR_WIDTH - 1:0];

    assign shiftreg_in = s_dividend as t_shiftreg;

    always_comb {
        shiftreg_next = shiftreg << 1;
        if !sub_sign {
            shiftreg_next[QUOTIENT_WIDTH +: DIVISOR_WIDTH] = sub_value;
        }
        shiftreg_next[0] = ~sub_sign;
    }

    var sub0: t_subtraction;
    var sub1: t_subtraction;
    assign sub0 = shiftreg_next[QUOTIENT_WIDTH-1 +: DIVISOR_WIDTH+1];
    assign sub1 = {1'b0, divisor};

    always_ff (clk, reset) {
        if_reset {
            m_valid     = 1'b0;
            busy        = 1'b0;
            cycle       = 'x;
            divisor     = 'x;
            shiftreg    = 'x;
            subtraction = 'x;
        } else {
            if (cke && (!m_valid || m_ready)) {
                if busy {
                    cycle -= 1;
                    m_valid = (cycle == '0);
                    subtraction = shiftreg_next[QUOTIENT_WIDTH-1 +: DIVISOR_WIDTH+1] - {1'b0, divisor};
                    shiftreg = shiftreg_next;
                    if m_valid {
                        busy = 1'b0;
                    }
                } else {
                    if s_valid && s_ready {
                        busy        = 1'b1;
                        cycle       = (CYCLE - 1) as t_cycle;
                        divisor     = s_divisor;
                        shiftreg    = shiftreg_in;
                        subtraction = shiftreg_in[QUOTIENT_WIDTH-1 +: DIVISOR_WIDTH+1] - {1'b0, divisor};
                    }
                }
            }
        }
    }

    assign s_ready     = ~busy;
    assign m_quotient  = shiftreg[0 +: QUOTIENT_WIDTH] as t_quotient;
    assign m_remainder = shiftreg[QUOTIENT_WIDTH +: DIVISOR_WIDTH] as t_remainder;
}
