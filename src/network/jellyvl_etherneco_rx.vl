module etherneco_rx #() (
    reset: input logic,
    clk  : input logic,

    rx_start: output logic,
    rx_end  : output logic,
    rx_error: output logic,

    s_first: input logic   ,
    s_last : input logic   ,
    s_data : input logic<8>,
    s_valid: input logic   ,

    m_first: output logic   ,
    m_last : output logic   ,
    m_data : output logic<8>,
    m_valid: output logic   ,
) {

    enum STATE: logic<5> {
        IDLE = 5'b00000,
        LENGTH = 5'b00010,
        PAYLOAD = 5'b00100,
        FCS = 5'b01000,
        ERROR = 5'b10000,
    }

    localparam t_length: type = logic<16>;

    var state     : STATE   ;
    var count     : t_length;
    var length    : t_length;
    var preamble  : logic   ;
    var crc_update: logic   ;
    var crc_check : logic   ;

    var count_next: t_length;
    assign count_next = count + 1'b1;

    always_ff (clk, reset) {
        if_reset {
            rx_start = 1'b0;
            rx_end   = 1'b0;
            rx_error = 1'b0;

            m_first = 'x;
            m_last  = 'x;
            m_data  = 'x;
            m_valid = 1'b0;

            state      = STATE::IDLE;
            count      = 'x;
            length     = 'x;
            preamble   = 1'b0;
            crc_update = 'x;
            crc_check  = 1'b0;
        } else {
            rx_start  = 1'b0;
            rx_end    = 1'b0;
            rx_error  = 1'b0;
            crc_check = 1'b0;

            if s_valid {
                count = count_next;

                case state {
                    STATE::IDLE: {
                        if preamble && (s_data == 8'hd5) && (count >= 6 && count <= 8) {
                            state      = STATE::LENGTH;
                            count      = 16'd1;
                            crc_update = 1'b0;
                        }
                        m_first = 1'bx;
                        m_last  = 1'bx;
                    }

                    STATE::LENGTH: {
                        if count[0] {
                            length[7:0] = s_data;
                            crc_update  = 1'b1;
                            m_first     = 1'bx;
                            m_last      = 1'bx;
                        } else {
                            state        = STATE::PAYLOAD;
                            count        = 16'd1;
                            length[15:8] = s_data;
                            m_first      = 1'b1;
                            m_last       = ({s_data, length[7:0]} == 16'd1);
                        }
                    }

                    STATE::PAYLOAD: {
                        m_first = 1'b0;
                        m_last  = (count_next == length);
                        if m_last {
                            state  = STATE::FCS;
                            count  = 16'd1;
                            length = 'x;
                        }
                    }

                    STATE::FCS: {
                        if count == 3'd5 {
                            state     = STATE::IDLE;
                            crc_check = 1'b1;
                        }
                    }

                    default: {
                        state = STATE::IDLE;
                    }
                }

                if s_data != 8'h55 {
                    preamble = 1'b0;
                }

                if s_first {
                    count    = 16'd1;
                    preamble = (s_data == 8'h55);
                    rx_start = (state == STATE::IDLE);
                }

                if (s_first && state != STATE::IDLE && state != STATE::ERROR) || (s_last && !(state == STATE::FCS && count == 5) && state != STATE::IDLE && state != STATE::ERROR) {
                    state   = STATE::ERROR;
                    m_first = 'x;
                    m_last  = 'x;
                    m_data  = 'x;
                    m_valid = 1'b0;
                }
            }

            if state == STATE::ERROR {
                state   = STATE::IDLE;
                m_first = 'x;
                m_last  = 'x;
                m_data  = 'x;
                m_valid = 1'b0;
            }

            if crc_check {
                if crc_value == 32'h2144df1c {
                    rx_end = 1'b1;
                } else {
                    rx_error = 1'b1;
                }
            }
        }
    }

    var crc_value: logic<32>;

    inst u_cacl_crc: jelly2_calc_crc #(
        DATA_WIDTH: 8           ,
        CRC_WIDTH : 32          ,
        POLY_REPS : 32'h04C11DB7,
        REVERSED  : 0           ,
    ) (
        reset: reset,
        clk  : clk  ,
        cke  : 1'b1 ,

        in_update: crc_update,
        in_data  : s_data    ,
        in_valid : s_valid   ,

        out_crc: crc_value,
    );

    // crc_value == 0x2144df1c

}
