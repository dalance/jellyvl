module etherneco_synctimer_slave #(
    parameter TIMER_WIDTH      : u32 = 64                             , // タイマのbit幅
    parameter NUMERATOR        : u32 = 10                             , // クロック周期の分子
    parameter DENOMINATOR      : u32 = 3                              , // クロック周期の分母
    parameter ADJ_COUNTER_WIDTH: u32 = 32                             , // 自クロックで経過時間カウンタのbit数
    parameter ADJ_CALC_WIDTH   : u32 = 32                             , // タイマのうち計算に使う部分
    parameter ADJ_ERROR_WIDTH  : u32 = 32                             , // 誤差計算時のbit幅
    parameter ADJ_ERROR_Q      : u32 = 8                              , // 誤差計算時に追加する固定小数点数bit数
    parameter ADJ_ADJUST_WIDTH : u32 = ADJ_COUNTER_WIDTH + ADJ_ERROR_Q, // 補正周期のbit幅
    parameter ADJ_ADJUST_Q     : u32 = ADJ_ERROR_Q                    , // 補正周期に追加する固定小数点数bit数
    parameter ADJ_PERIOD_WIDTH : u32 = ADJ_ERROR_WIDTH                , // 周期補正に使うbit数
    parameter ADJ_PHASE_WIDTH  : u32 = ADJ_ERROR_WIDTH                , // 位相補正に使うbit数
) (
    reset: input logic,
    clk  : input logic,

    current_time: output logic<TIMER_WIDTH>,

    // command
    cmd_rx_start : input logic    ,
    cmd_rx_end   : input logic    ,
    cmd_rx_error : input logic    ,
    cmd_rx_length: input logic<16>,
    cmd_rx_type  : input logic<8> ,
    cmd_rx_node  : input logic<8> ,

    s_cmd_first: input  logic    ,
    s_cmd_last : input  logic    ,
    s_cmd_pos  : input  logic<16>,
    s_cmd_data : input  logic<8> ,
    s_cmd_valid: input  logic    ,
    m_cmd_data : output logic<8> ,
    m_cmd_valid: output logic    ,

    // downstream
    res_rx_start : input logic    ,
    res_rx_end   : input logic    ,
    res_rx_error : input logic    ,
    res_rx_length: input logic<16>,
    res_rx_type  : input logic<8> ,
    res_rx_node  : input logic<8> ,

    s_res_first: input  logic    ,
    s_res_last : input  logic    ,
    s_res_pos  : input  logic<16>,
    s_res_data : input  logic<8> ,
    s_res_valid: input  logic    ,
    m_res_data : output logic<8> ,
    m_res_valid: output logic    ,
) {

    // ---------------------------------
    //  Timer
    // ---------------------------------

    localparam t_adj_phase: type = signed logic<ADJ_PHASE_WIDTH>;
    localparam t_time     : type = logic<TIMER_WIDTH>;

    var correct_override: logic ;
    var correct_time    : t_time;
    var correct_valid   : logic ;

    inst u_synctimer_core: synctimer_core #(
        TIMER_WIDTH      : TIMER_WIDTH      ,
        NUMERATOR        : NUMERATOR        ,
        DENOMINATOR      : DENOMINATOR      ,
        ADJ_COUNTER_WIDTH: ADJ_COUNTER_WIDTH,
        ADJ_CALC_WIDTH   : ADJ_CALC_WIDTH   ,
        ADJ_ERROR_WIDTH  : ADJ_ERROR_WIDTH  ,
        ADJ_ERROR_Q      : ADJ_ERROR_Q      ,
        ADJ_ADJUST_WIDTH : ADJ_ADJUST_WIDTH ,
        ADJ_ADJUST_Q     : ADJ_ADJUST_Q     ,
        ADJ_PERIOD_WIDTH : ADJ_PERIOD_WIDTH ,
        ADJ_PHASE_WIDTH  : ADJ_PHASE_WIDTH  ,
    ) (
        reset: reset,
        clk  : clk  ,

        adj_param_phase_min: -10 as t_adj_phase,
        adj_param_phase_max: +10 as t_adj_phase,

        set_time : '0  ,
        set_valid: 1'b0,

        current_time: current_time,

        correct_override: correct_override,
        correct_time    : correct_time    ,
        correct_valid   : correct_valid   ,
    );

    localparam t_time32    : type     = logic<32>;
    var start_time  : t_time32;
    var elapsed_time: t_time32;

    always_ff (clk) {
        if cmd_rx_end {
            start_time = current_time[31:0];
        }

        if res_rx_start {
            elapsed_time = current_time[31:0] - start_time;
        }
    }


    // ---------------------------------
    //  Upstream (receive request)
    // ---------------------------------

    var up_reset: logic;
    assign up_reset = reset || cmd_rx_error;

    var cmd_rx_cmd   : logic <8> ;
    var cmd_rx_time  : t_time    ;
    var cmd_rx_offset: logic <16>;

    always_ff (clk, up_reset) {
        if_reset {
            cmd_rx_cmd    = 'x;
            cmd_rx_time   = 'x;
            cmd_rx_offset = 'x;
        } else {
            if s_cmd_valid {
                case s_cmd_pos as int {
                    0 : cmd_rx_cmd              = s_cmd_data;
                    1 : cmd_rx_time[0 * 8+:8]   = s_cmd_data;
                    2 : cmd_rx_time[1 * 8+:8]   = s_cmd_data;
                    3 : cmd_rx_time[2 * 8+:8]   = s_cmd_data;
                    4 : cmd_rx_time[3 * 8+:8]   = s_cmd_data;
                    5 : cmd_rx_time[4 * 8+:8]   = s_cmd_data;
                    6 : cmd_rx_time[5 * 8+:8]   = s_cmd_data;
                    7 : cmd_rx_time[6 * 8+:8]   = s_cmd_data;
                    8 : cmd_rx_time[7 * 8+:8]   = s_cmd_data;
                    9 : cmd_rx_offset[0 * 8+:8] = s_cmd_data;
                    10: cmd_rx_offset[1 * 8+:8] = s_cmd_data;
                }
            }
        }
    }

    always_ff (clk, up_reset) {
        if_reset {
            correct_override = 1'bx;
            correct_time     = 'x;
            correct_valid    = 1'b0;
        } else {
            correct_override = 1'bx;
            correct_time     = cmd_rx_time + cmd_rx_offset as t_time;
            correct_valid    = 1'b0;

            if cmd_rx_end {
                case cmd_rx_cmd {
                    8'h00: {
                        correct_override = 1'bx;
                        correct_valid    = 1'b0;
                    }
                    8'h01: {
                        correct_override = 1'b0;
                        correct_valid    = 1'b1;
                    }
                    8'h03: {
                        correct_override = 1'b1;
                        correct_valid    = 1'b1;
                    }
                    default: {
                        correct_override = 1'b1;
                        correct_valid    = 1'b1;
                    }
                }
            }
        }
    }

    assign m_cmd_data  = 'x;
    assign m_cmd_valid = 1'b0;


    // ---------------------------------
    //  Downstream (send response)
    // ---------------------------------

    var down_reset: logic;
    assign down_reset = reset || res_rx_error;

    var res_pos: logic<16>;
    assign res_pos = 9 + cmd_rx_node * 4;

    always_ff (clk, up_reset) {
        if_reset {
            m_res_data  = 'x;
            m_res_valid = 1'b0;
        } else {
            m_res_data  = 'x;
            m_res_valid = 1'b0;
            if s_res_valid {
                if s_res_pos == res_pos + 16'd0 {
                    m_res_data  = elapsed_time[0 * 8+:8];
                    m_res_valid = 1'b1;
                }
                if s_res_pos == res_pos + 16'd1 {
                    m_res_data  = elapsed_time[1 * 8+:8];
                    m_res_valid = 1'b1;
                }
                if s_res_pos == res_pos + 16'd2 {
                    m_res_data  = elapsed_time[2 * 8+:8];
                    m_res_valid = 1'b1;
                }
                if s_res_pos == res_pos + 16'd3 {
                    m_res_data  = elapsed_time[3 * 8+:8];
                    m_res_valid = 1'b1;
                }
            }
        }
    }
}
