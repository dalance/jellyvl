module etherneco_synctimer_master #(
    parameter TIMER_WIDTH: u32 = 64, // タイマのbit幅
    parameter NUMERATOR  : u32 = 10, // クロック周期の分子
    parameter DENOMINATOR: u32 = 3 , // クロック周期の分母

) (
    reset: input logic,
    clk  : input logic,

    current_time: output logic<TIMER_WIDTH>,

    sync_start   : input logic,
    sync_override: input logic,

    m_cmd_tx_last : output logic   ,
    m_cmd_tx_data : output logic<8>,
    m_cmd_tx_valid: output logic   ,
    m_cmd_tx_ready: input  logic   ,

    ret_rx_start     : input  logic    ,
    ret_rx_end       : input  logic    ,
    ret_rx_error     : input  logic    ,
    ret_rx_length    : input  logic<16>,
    ret_rx_type      : input  logic<8> ,
    ret_rx_node      : input  logic<8> ,
    ret_payload_first: input  logic    ,
    ret_payload_last : input  logic    ,
    ret_payload_pos  : input  logic<16>,
    ret_payload_data : input  logic<8> ,
    ret_payload_valid: input  logic    ,
    ret_replace_data : output logic<8> ,
    ret_replace_valid: output logic    ,

    res_rx_start     : input logic    ,
    res_rx_end       : input logic    ,
    res_rx_error     : input logic    ,
    res_rx_length    : input logic<16>,
    res_rx_type      : input logic<8> ,
    res_rx_node      : input logic<8> ,
    res_payload_first: input logic    ,
    res_payload_last : input logic    ,
    res_payload_pos  : input logic<16>,
    res_payload_data : input logic<8> ,
    res_payload_valid: input logic    ,
) {


    // タイマ
    var adjust_ready: logic;
    inst u_synctimer_timer: synctimer_timer #(
        NUMERATOR  : NUMERATOR  ,
        DENOMINATOR: DENOMINATOR,
        TIMER_WIDTH: TIMER_WIDTH,
    ) (
        reset: reset,
        clk  : clk  ,

        set_time : '0  ,
        set_valid: 1'b0,

        adjust_sign : 1'b0        ,
        adjust_valid: 1'b0        ,
        adjust_ready: adjust_ready,

        current_time: current_time,
    );

    localparam LENGTH: u32 = 4 + 8 + 1;

    var last: logic<LENGTH, 1>;
    var data: logic<LENGTH, 8>;

    always_ff (clk, reset) {
        if_reset {
            last           = 'x;
            data           = 'x;
            m_cmd_tx_valid = 1'b0;
        } else {
            if sync_start {
                // command_id
                data[0] = if sync_override {
                    8'h01
                } else {
                    8'h00
                };
                last[0] = 1'b0;

                // time
                data[8:1] = current_time;
                last[8:1] = 8'h00;

                // offset
                data[12:9] = 32'd1000;
                last[12:9] = 4'b1000;

                m_cmd_tx_valid = 1'b1;
            } else {
                if m_cmd_tx_valid && m_cmd_tx_ready {
                    data           >>= 8;
                    last           >>= 1;
                    m_cmd_tx_valid =   !m_cmd_tx_last;
                }
            }
        }
    }

    assign m_cmd_tx_data = data[0];
    assign m_cmd_tx_last = last[0];

}
